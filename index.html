<!DOCTYPE html>
<html lang="ko">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
<title>ë™ë¬¼ ê¸¸ê±´ë„ˆ ğŸ”</title>
<style>
  * { margin:0; padding:0; box-sizing:border-box; }
  body { overflow:hidden; font-family:'Segoe UI',sans-serif; background:#87CEEB; }
  canvas { display:block; }

  #score {
    position:fixed; top:20px; left:50%; transform:translateX(-50%);
    font-size:60px; font-weight:900; color:#fff;
    text-shadow:0 3px 0 rgba(0,0,0,.4);
    display:none; pointer-events:none; z-index:10;
  }

  .overlay {
    position:fixed; inset:0; display:flex; flex-direction:column;
    align-items:center; justify-content:center;
    background:rgba(0,0,0,.55); z-index:20;
  }
  .overlay h1 { font-size:46px; color:#fff; margin-bottom:10px; text-shadow:0 2px 8px rgba(0,0,0,.5); }
  .overlay p  { font-size:20px; color:#ccc; margin-bottom:38px; }
  .score-big  { font-size:84px; font-weight:900; color:#fff; line-height:1; }
  .best       { font-size:24px; color:#FFD700; margin-bottom:34px; }

  button {
    padding:14px 48px; font-size:24px; font-weight:700;
    border:none; border-radius:14px; cursor:pointer;
    transition:transform .1s; color:#fff;
  }
  button:active { transform:scale(.94); }
  .btn-green { background:#2ecc71; }
  .btn-blue  { background:#3498db; }

  #dpad {
    position:fixed; right:20px; bottom:20px;
    display:none; grid-template-columns:repeat(3,58px);
    grid-template-rows:repeat(2,58px); gap:4px; z-index:15;
  }
  #dpad button {
    padding:0; font-size:26px; background:rgba(255,255,255,.22);
    backdrop-filter:blur(4px); border-radius:10px; color:#fff;
  }
  .dp-up    { grid-area:1/2; }
  .dp-left  { grid-area:2/1; }
  .dp-right { grid-area:2/3; }

  #legend {
    position:fixed; bottom:20px; left:16px;
    font-size:13px; color:rgba(255,255,255,.8);
    pointer-events:none; z-index:10; line-height:1.6;
    text-shadow:0 1px 3px rgba(0,0,0,.5);
    display:none;
  }
</style>
</head>
<body>

<div id="score">0</div>
<div id="legend">ğŸ„ ì†ŒÂ·ë¼ì§€ â€” í”¼í•˜ê¸°<br>ğŸ¯ ë§¹ìˆ˜ â€” ë¹ ë¦„! ì¡°ì‹¬<br>ğŸ ë±€ â€” ì´ˆê³ ì† ìœ„í—˜</div>

<div class="overlay" id="menu">
  <h1>ğŸ” ë™ë¬¼ ê¸¸ê±´ë„ˆ</h1>
  <p>ì†ŒÂ·ë¼ì§€Â·ë§¹ìˆ˜Â·ë±€ì„ í”¼í•´ ì•ìœ¼ë¡œ!</p>
  <button class="btn-green" id="btnStart">ì‹œ  ì‘</button>
</div>

<div class="overlay" id="gameover" style="display:none">
  <h1 style="color:#e74c3c">ê²Œì„ ì˜¤ë²„</h1>
  <div class="score-big" id="finalScore">0</div>
  <div class="best" id="bestScore">ìµœê³ : 0</div>
  <button class="btn-blue" id="btnRetry">ë‹¤ì‹œí•˜ê¸°</button>
</div>

<div id="dpad">
  <button class="dp-up"    data-dx="0"  data-dz="-1">â–²</button>
  <button class="dp-left"  data-dx="-1" data-dz="0">â—€</button>
  <button class="dp-right" data-dx="1"  data-dz="0">â–¶</button>
</div>

<script type="importmap">
{
  "imports": {
    "three": "https://cdn.jsdelivr.net/npm/three@0.166.1/build/three.module.js",
    "cannon-es": "https://esm.sh/cannon-es@0.20.0"
  }
}
</script>

<script type="module">
import * as THREE  from 'three';
import * as CANNON from 'cannon-es';

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// ìƒìˆ˜
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
const BOARD_HALF  = 4;
const TILE_SIZE   = 1;
const GEN_AHEAD   = 35;
const CULL_BEHIND = 8;
const GRAVITY     = 22;
const JUMP_H      = 0.5;
const JUMP_VEL    = Math.sqrt(2 * GRAVITY * JUMP_H);
const JUMP_TIME   = (2 * JUMP_VEL) / GRAVITY;
const CAM_OFFSET  = new THREE.Vector3(6, 8, 6);
const TileType    = { GRASS:0, ROAD:1, RIVER:2 };

// â•â•â•â• ìƒ‰ìƒ íŒ”ë ˆíŠ¸ â•â•â•â•
const COL = {
  sky:      0x87CEEB,
  grass:    0x5aad3e,
  road:     0x9B7D56,     // í™ê¸¸ (ê°ˆìƒ‰)
  snakeLane:0x2A4A1A,     // ë±€ê¸¸ (ì§™ì€ ë…¹ìƒ‰)
  // ì†Œ (Cow)
  cow:      0xF2EDD0,
  cow_dark: 0x3D2411,
  // ë¼ì§€ (Pig)
  pig:      0xFFB6C1,
  pig_snout:0xF5919C,
  // ë±€ (Snake)
  snake:    0x27AE60,
  snake_dk: 0x145A32,
  // í˜¸ë‘ì´ (Tiger)
  tiger:    0xE67E22,
  tiger_s:  0x1A1A1A,
  // ê³° (Bear)
  bear:     0x6B3A2A,
  bear_lt:  0xA0612A,
  // í”Œë ˆì´ì–´ (ë‹­)
  yellow:   0xFFD700,
  orange:   0xFF8C00,
  // ê¸°íƒ€
  tree:     0x27ae60,
  trunk:    0x6B3F1A,
  white:    0xffffff,
  dark:     0x111111,
};

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// Three.js ì´ˆê¸°í™”
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
const renderer = new THREE.WebGLRenderer({ antialias:true });
renderer.setPixelRatio(Math.min(devicePixelRatio, 2));
renderer.setSize(innerWidth, innerHeight);
renderer.shadowMap.enabled = true;
renderer.shadowMap.type    = THREE.PCFSoftShadowMap;
document.body.prepend(renderer.domElement);

const scene  = new THREE.Scene();
scene.background = new THREE.Color(COL.sky);
scene.fog = new THREE.Fog(COL.sky, 16, 28);

const camera = new THREE.PerspectiveCamera(52, innerWidth/innerHeight, 0.1, 100);
camera.position.copy(CAM_OFFSET);
camera.lookAt(0,0,0);

const sun = new THREE.DirectionalLight(0xffffff, 1.5);
sun.position.set(6, 14, 8); sun.castShadow = true;
sun.shadow.mapSize.set(1024,1024);
['left','right','top','bottom'].forEach(d => sun.shadow.camera[d] = (d==='left'||d==='bottom') ? -14 : 14);
sun.shadow.camera.far = 60;
scene.add(sun, new THREE.AmbientLight(0xffffff, 0.5));

window.addEventListener('resize', () => {
  renderer.setSize(innerWidth, innerHeight);
  camera.aspect = innerWidth/innerHeight;
  camera.updateProjectionMatrix();
});

// ë°•ìŠ¤ ë©”ì‰¬ í—¬í¼
function box(w, h, d, color, shadow=true) {
  const m = new THREE.Mesh(
    new THREE.BoxGeometry(w,h,d),
    new THREE.MeshLambertMaterial({color})
  );
  m.castShadow = m.receiveShadow = shadow;
  return m;
}

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// Cannon.js ì´ˆê¸°í™”
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
const world = new CANNON.World({ gravity: new CANNON.Vec3(0, -GRAVITY, 0) });
world.broadphase = new CANNON.SAPBroadphase(world);
world.allowSleep  = false;

const matPlayer = new CANNON.Material('player');
const matGround = new CANNON.Material('ground');
const matAnimal = new CANNON.Material('animal');
world.addContactMaterial(new CANNON.ContactMaterial(matPlayer, matGround, { restitution:0, friction:0 }));
world.addContactMaterial(new CANNON.ContactMaterial(matPlayer, matAnimal, { restitution:0, friction:0 }));

// ì§€ë©´
const groundBody = new CANNON.Body({ mass:0, material:matGround });
groundBody.addShape(new CANNON.Plane());
groundBody.quaternion.setFromEuler(-Math.PI/2, 0, 0);
world.addBody(groundBody);

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// í”Œë ˆì´ì–´ (ë‹­ ğŸ”)
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
const pGroup = new THREE.Group(); scene.add(pGroup);
pGroup.rotation.y = Math.PI; // ê¸°ë³¸ ì•ìª½(-Z) í–¥í•˜ê²Œ

const pBody3 = box(0.55, 0.65, 0.55, COL.yellow); pBody3.name='Body'; pBody3.position.y=0.325; pGroup.add(pBody3);
const pHead  = box(0.4,  0.4,  0.4,  COL.yellow); pHead.name='Head';  pHead.position.set(0,0.84,0.07); pGroup.add(pHead);
const pBeak  = box(0.12, 0.08, 0.15, COL.orange); pBeak.name='Beak';  pBeak.position.set(0,0.79,0.3);  pGroup.add(pBeak);
// ë‹­ë²¼ìŠ¬
const comb = box(0.08,0.14,0.12,0xE74C3C); comb.position.set(0,1.08,0.02); pGroup.add(comb);
// ë‚ ê°œ
const wingL = box(0.08,0.28,0.38,0xF0C800); wingL.position.set( 0.33,0.52,0); wingL.rotation.z= 0.25; pGroup.add(wingL);
const wingR = box(0.08,0.28,0.38,0xF0C800); wingR.position.set(-0.33,0.52,0); wingR.rotation.z=-0.25; pGroup.add(wingR);

const playerShape = new CANNON.Box(new CANNON.Vec3(0.22, 0.45, 0.22));
const playerBody  = new CANNON.Body({ mass:1, material:matPlayer, linearDamping:0, angularDamping:1 });
playerBody.addShape(playerShape);
playerBody.position.set(0, 0.45, 0);
world.addBody(playerBody);

const player = {
  gridX:0, gridZ:0,
  isMoving:false, isDead:false,
  jumpStart:0, landX:0, landZ:0,
};

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// ê²Œì„ ìƒíƒœ
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
let gameState = 'menu';
let score     = 0;
let bestScore = +localStorage.getItem('animal_crossy_best') || 0;
let farRow    = 0;
const tiles    = {};
const vehicles = [];
const blocked  = new Set();

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// ë™ë¬¼ ë©”ì‰¬ í•¨ìˆ˜ë“¤
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

// ê³µí†µ: ë¨¸ë¦¬ëŠ” +X ë°©í–¥, ì´ë™ ë°©í–¥ì— ë”°ë¼ mesh.rotation.y ì¡°ì ˆ

function makeCow(x, z) {
  const g = new THREE.Group(); g.position.set(x,0,z);
  // ëª¸í†µ
  const body = box(1.02,0.48,0.58,COL.cow); body.position.y=0.24; g.add(body);
  // ì–¼ë£©
  const sp1=box(0.30,0.30,0.10,COL.cow_dark); sp1.position.set( 0.22,0.44, 0.30); g.add(sp1);
  const sp2=box(0.22,0.20,0.10,COL.cow_dark); sp2.position.set(-0.14,0.34,-0.31); g.add(sp2);
  // ë¨¸ë¦¬ (+X)
  const head=box(0.38,0.38,0.38,COL.cow); head.position.set(0.60,0.42,0); g.add(head);
  // ì£¼ë‘¥ì´
  const snout=box(0.18,0.16,0.30,0xDDD0B0); snout.position.set(0.76,0.35,0); g.add(snout);
  // ì½§êµ¬ë©
  [0.09,-0.09].forEach(nz=>{
    const n=box(0.04,0.04,0.04,0xBB9977); n.position.set(0.83,0.37,nz); g.add(n);
  });
  // ë¿”
  [0.11,-0.11].forEach(hz=>{
    const h2=box(0.05,0.18,0.05,0xF0E0A0); h2.position.set(0.52,0.66,hz); g.add(h2);
  });
  // ëˆˆ
  [0.13,-0.13].forEach(ez=>{
    const eye=box(0.06,0.06,0.04,COL.dark); eye.position.set(0.76,0.48,ez); g.add(eye);
  });
  // ë‹¤ë¦¬
  [[-0.3,-0.22],[-0.3,0.22],[0.3,-0.22],[0.3,0.22]].forEach(([lx,lz])=>{
    const leg=box(0.10,0.22,0.10,COL.cow_dark); leg.position.set(lx,-0.11,lz); g.add(leg);
  });
  // ê¼¬ë¦¬
  const tail=box(0.06,0.22,0.06,COL.cow_dark); tail.position.set(-0.60,0.28,0); tail.rotation.z=0.4; g.add(tail);
  scene.add(g);

  const phys = new CANNON.Body({mass:0, material:matAnimal, type:CANNON.Body.KINEMATIC});
  phys.addShape(new CANNON.Box(new CANNON.Vec3(0.51,0.24,0.29)));
  phys.position.set(x,0.24,z);
  world.addBody(phys);
  return {mesh:g, body:phys};
}

function makePig(x, z) {
  const g = new THREE.Group(); g.position.set(x,0,z);
  // ëª¸í†µ
  const body=box(0.78,0.46,0.62,COL.pig); body.position.y=0.23; g.add(body);
  // ë¨¸ë¦¬
  const head=box(0.44,0.42,0.46,COL.pig); head.position.set(0.52,0.36,0); g.add(head);
  // ì½”
  const snout=box(0.16,0.14,0.30,COL.pig_snout); snout.position.set(0.68,0.29,0); g.add(snout);
  [0.09,-0.09].forEach(nz=>{
    const n=box(0.05,0.05,0.05,0xD06070); n.position.set(0.74,0.31,nz); g.add(n);
  });
  // ê·€
  [0.19,-0.19].forEach(ez=>{
    const ear=box(0.08,0.14,0.14,0xFFAABB); ear.position.set(0.44,0.62,ez); g.add(ear);
  });
  // ëˆˆ
  [0.15,-0.15].forEach(ez=>{
    const eye=box(0.06,0.06,0.04,COL.dark); eye.position.set(0.72,0.44,ez); g.add(eye);
  });
  // ë‹¤ë¦¬
  [[-0.20,-0.22],[-0.20,0.22],[0.20,-0.22],[0.20,0.22]].forEach(([lx,lz])=>{
    const leg=box(0.12,0.18,0.12,0xFFAABB); leg.position.set(lx,-0.09,lz); g.add(leg);
  });
  // ê½ˆë°°ê¸° ê¼¬ë¦¬
  const tail=box(0.08,0.08,0.14,COL.pig); tail.position.set(-0.46,0.28,0); tail.rotation.z=-0.6; g.add(tail);
  scene.add(g);

  const phys = new CANNON.Body({mass:0, material:matAnimal, type:CANNON.Body.KINEMATIC});
  phys.addShape(new CANNON.Box(new CANNON.Vec3(0.39,0.23,0.31)));
  phys.position.set(x,0.23,z);
  world.addBody(phys);
  return {mesh:g, body:phys};
}

function makeSnake(x, z) {
  const g = new THREE.Group(); g.position.set(x,0,z);
  const segs=6, segW=0.44;
  for(let i=0; i<segs; i++){
    const c = i%2===0 ? COL.snake : COL.snake_dk;
    const s=box(segW,0.20,0.36,c); s.position.set(i*segW-(segs-1)*segW/2, 0.10, 0); g.add(s);
  }
  // ë¨¸ë¦¬ (+X ë)
  const hx = segs*segW/2;
  const head=box(0.52,0.24,0.42,COL.snake_dk); head.position.set(hx,0.12,0); g.add(head);
  // ëˆˆ
  [0.17,-0.17].forEach(ez=>{
    const eye=box(0.08,0.08,0.07,0xFF2222); eye.position.set(hx+0.16,0.22,ez); g.add(eye);
  });
  // í˜€ (ê°ˆë˜ì§„)
  const tongue=box(0.18,0.03,0.03,0xEE1111); tongue.position.set(hx+0.36,0.14, 0.04); tongue.rotation.z=0.2; g.add(tongue);
  const tongue2=box(0.18,0.03,0.03,0xEE1111); tongue2.position.set(hx+0.36,0.14,-0.04); tongue2.rotation.z=-0.2; g.add(tongue2);
  // ë°©ìš¸ê¼¬ë¦¬ (-X ë)
  const rattle=box(0.20,0.16,0.20,0xCCCC00); rattle.position.set(-segs*segW/2-0.1, 0.08, 0); g.add(rattle);
  scene.add(g);

  const halfW = (segs*segW+0.52)/2;
  const phys = new CANNON.Body({mass:0, material:matAnimal, type:CANNON.Body.KINEMATIC});
  phys.addShape(new CANNON.Box(new CANNON.Vec3(halfW, 0.12, 0.21)));
  phys.position.set(x,0.12,z);
  world.addBody(phys);
  return {mesh:g, body:phys};
}

function makeTiger(x, z) {
  const g = new THREE.Group(); g.position.set(x,0,z);
  // ëª¸í†µ
  const body=box(0.90,0.52,0.58,COL.tiger); body.position.y=0.26; g.add(body);
  // ì¤„ë¬´ëŠ¬
  [-0.26, 0.04, 0.30].forEach(sx=>{
    const st=box(0.07,0.54,0.60,COL.tiger_s); st.position.set(sx,0.27,0); g.add(st);
  });
  // ë¨¸ë¦¬
  const head=box(0.44,0.44,0.44,COL.tiger); head.position.set(0.58,0.44,0); g.add(head);
  // ì£¼ë‘¥ì´ (í°ìƒ‰)
  const muz=box(0.28,0.24,0.36,0xF5DEB3); muz.position.set(0.76,0.38,0); g.add(muz);
  // ê·€
  [0.18,-0.18].forEach(ez=>{
    const ear=box(0.10,0.14,0.10,COL.tiger); ear.position.set(0.54,0.76,ez); g.add(ear);
    const earI=box(0.06,0.08,0.06,0xFFBBBB); earI.position.set(0.54,0.78,ez); g.add(earI);
  });
  // ëˆˆ (ë…¸ë€)
  [0.14,-0.14].forEach(ez=>{
    const eye=box(0.10,0.10,0.06,0xFFDD00); eye.position.set(0.78,0.52,ez); g.add(eye);
    const pupil=box(0.04,0.08,0.04,COL.dark); pupil.position.set(0.82,0.52,ez); g.add(pupil);
  });
  // ì½”
  const nose=box(0.06,0.06,0.04,0x222222); nose.position.set(0.86,0.44,0); g.add(nose);
  // ë‹¤ë¦¬
  [[-0.28,-0.22],[-0.28,0.22],[0.22,-0.22],[0.22,0.22]].forEach(([lx,lz])=>{
    const leg=box(0.12,0.26,0.12,COL.tiger); leg.position.set(lx,-0.13,lz); g.add(leg);
  });
  // ê¼¬ë¦¬
  const tail=box(0.08,0.32,0.08,COL.tiger); tail.position.set(-0.56,0.30,0); tail.rotation.z=0.5; g.add(tail);
  const tailTip=box(0.10,0.12,0.10,COL.tiger_s); tailTip.position.set(-0.58,0.54,0); g.add(tailTip);
  scene.add(g);

  const phys = new CANNON.Body({mass:0, material:matAnimal, type:CANNON.Body.KINEMATIC});
  phys.addShape(new CANNON.Box(new CANNON.Vec3(0.45,0.26,0.29)));
  phys.position.set(x,0.26,z);
  world.addBody(phys);
  return {mesh:g, body:phys};
}

function makeBear(x, z) {
  const g = new THREE.Group(); g.position.set(x,0,z);
  // ëª¸í†µ
  const body=box(0.88,0.62,0.64,COL.bear); body.position.y=0.31; g.add(body);
  // ë°° (ë°ì€ ìƒ‰)
  const belly=box(0.44,0.50,0.66,COL.bear_lt); belly.position.set(0.18,0.31,0); g.add(belly);
  // ë¨¸ë¦¬
  const head=box(0.54,0.52,0.54,COL.bear); head.position.set(0.64,0.52,0); g.add(head);
  // ì£¼ë‘¥ì´
  const muz=box(0.28,0.24,0.36,COL.bear_lt); muz.position.set(0.84,0.46,0); g.add(muz);
  // ê·€ (ë‘¥ê¸€ê²Œ)
  [0.22,-0.22].forEach(ez=>{
    const ear=box(0.16,0.18,0.16,COL.bear); ear.position.set(0.56,0.80,ez); g.add(ear);
    const earI=box(0.08,0.10,0.08,COL.bear_lt); earI.position.set(0.56,0.82,ez); g.add(earI);
  });
  // ëˆˆ
  [0.16,-0.16].forEach(ez=>{
    const eye=box(0.08,0.10,0.06,COL.dark); eye.position.set(0.83,0.58,ez); g.add(eye);
  });
  // ì½”
  const nose=box(0.10,0.08,0.06,COL.dark); nose.position.set(0.93,0.50,0); g.add(nose);
  // ë‹¤ë¦¬ (êµµìŒ)
  [[-0.26,-0.24],[-0.26,0.24],[0.26,-0.24],[0.26,0.24]].forEach(([lx,lz])=>{
    const leg=box(0.16,0.30,0.16,COL.bear); leg.position.set(lx,-0.15,lz); g.add(leg);
  });
  scene.add(g);

  const phys = new CANNON.Body({mass:0, material:matAnimal, type:CANNON.Body.KINEMATIC});
  phys.addShape(new CANNON.Box(new CANNON.Vec3(0.44,0.31,0.32)));
  phys.position.set(x,0.31,z);
  world.addBody(phys);
  return {mesh:g, body:phys};
}

function makeTree(x, z) {
  const trunk = box(0.22,0.38,0.22,COL.trunk); trunk.position.set(x,0.19,z);
  const leaf  = box(0.65,0.68,0.65,COL.tree);  leaf.position.set(x,0.72,z);
  scene.add(trunk,leaf);
  return {trunk,leaf,_tree:true};
}

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// íƒ€ì¼ ìƒì„±
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
function tileType(r) {
  if (r <= 0) return TileType.GRASS;
  const rnd = Math.random();
  return rnd < 0.36 ? TileType.GRASS : rnd < 0.70 ? TileType.ROAD : TileType.RIVER;
}

function genRow(r) {
  if (tiles[r]) return;
  const z   = -r * TILE_SIZE;
  const typ = tileType(r);
  const meshes = [];

  // â”€â”€ ë°”ë‹¥ â”€â”€
  const floorColors = [COL.grass, COL.road, COL.snakeLane];
  const floor = box(40, 0.2, TILE_SIZE, floorColors[typ], false);
  floor.position.set(0,-0.1,z); scene.add(floor); meshes.push(floor);

  // í™ê¸¸ ì¥ì‹ (ì‘ì€ ëŒ)
  if (typ === TileType.ROAD) {
    for (let x=-3; x<=3; x+=2) {
      if (Math.random()<0.4) {
        const rock=box(0.13,0.07,0.13,0x887766,false);
        rock.position.set(x+Math.random()*0.5-0.25,0.01,z);
        scene.add(rock); meshes.push(rock);
      }
    }
  }

  // ë±€ê¸¸ ì¥ì‹ (ì§™ì€ í’€ ì˜¤ë²„ë ˆì´)
  if (typ === TileType.RIVER) {
    const overlay=box(9,0.04,0.72,0x1A3A0A,false);
    overlay.position.set(0,0.01,z); scene.add(overlay); meshes.push(overlay);
    // ì´ë¼
    for(let i=0;i<4;i++){
      const m=box(0.26,0.03,0.22,0x2A5A10,false);
      m.position.set(-3.5+i*2+Math.random()*1.2,0.02,z+Math.random()*0.3-0.15);
      scene.add(m); meshes.push(m);
    }
  }

  // â”€â”€ ì”ë”” ë‚˜ë¬´ â”€â”€
  if (typ === TileType.GRASS && r > 0) {
    const cnt = Math.floor(Math.random()*3);
    const used = new Set();
    for (let i=0; i<cnt; i++) {
      const x = Math.floor(Math.random()*9)-4;
      const key = `${x},${r}`;
      if (used.has(x) || blocked.has(key)) continue;
      if (r===1 && x===0) continue;
      used.add(x); blocked.add(key);
      const grp = makeTree(x, z); meshes.push(grp);
    }
  }

  // â”€â”€ ê°€ì¶•ê¸¸ (ROAD): ì†Œ/ë¼ì§€ ë˜ëŠ” ë§¹ìˆ˜(í˜¸ë‘ì´/ê³°) â”€â”€
  if (typ === TileType.ROAD) {
    const dir   = Math.random()<.5 ? 1:-1;
    // ì§„í–‰í• ìˆ˜ë¡ ë§¹ìˆ˜ í™•ë¥  ì¦ê°€
    const beastChance = Math.min(0.1 + r * 0.015, 0.38);
    const isBeast = r > 4 && Math.random() < beastChance;
    const spd   = isBeast
      ? 2.6 + Math.random()*2.0      // ë§¹ìˆ˜: ë¹ ë¦„ (2.6~4.6)
      : 0.7 + Math.random()*1.8;     // ê°€ì¶•: ëŠë¦¼ (0.7~2.5)
    const cnt   = 1+Math.floor(Math.random()*3);

    for (let i=0; i<cnt; i++) {
      const sx = Math.random()*8-4;
      let mObj;
      if (isBeast) {
        mObj = Math.random()<0.5 ? makeTiger(sx,z) : makeBear(sx,z);
      } else {
        mObj = Math.random()<0.55 ? makeCow(sx,z) : makePig(sx,z);
      }
      // ì´ë™ ë°©í–¥ìœ¼ë¡œ ë¨¸ë¦¬ ëŒë¦¬ê¸°
      mObj.mesh.rotation.y = dir < 0 ? Math.PI : 0;
      mObj.body.velocity.x = dir * spd;
      const v = {mesh:mObj.mesh, body:mObj.body, rowIdx:r, dir, spd, bound:6.0};
      vehicles.push(v); meshes.push(mObj.mesh);
      if (gameState!=='menu') registerAnimal(v);
    }
  }

  // â”€â”€ ë±€ê¸¸ (RIVER): ë±€ â€” ë¹ ë¥¸ ì¹˜ëª… ì¥ì• ë¬¼ â”€â”€
  if (typ === TileType.RIVER) {
    const dir = Math.random()<.5 ? 1:-1;
    const spd = 2.2 + Math.random()*2.8;   // ë±€: ì´ˆê³ ì† (2.2~5.0)
    const cnt = 1+Math.floor(Math.random()*2);
    for (let i=0; i<cnt; i++) {
      const sx = Math.random()*8-4;
      const mObj = makeSnake(sx,z);
      mObj.mesh.rotation.y = dir < 0 ? Math.PI : 0;
      mObj.body.velocity.x = dir * spd;
      const v = {mesh:mObj.mesh, body:mObj.body, rowIdx:r, dir, spd, bound:8.0};
      vehicles.push(v); meshes.push(mObj.mesh);
      if (gameState!=='menu') registerAnimal(v);
    }
  }

  tiles[r] = {type:typ, z, meshes};
}

function removeRow(r) {
  if (!tiles[r]) return;
  const {meshes} = tiles[r];
  for (const m of meshes) {
    if (m._tree) { scene.remove(m.trunk, m.leaf); }
    else if (m.isObject3D) scene.remove(m);
  }
  for (let x=-4; x<=4; x++) blocked.delete(`${x},${r}`);
  for (let i=vehicles.length-1; i>=0; i--) {
    const v=vehicles[i];
    if (v.rowIdx!==r) continue;
    world.removeBody(v.body);
    scene.remove(v.mesh);
    animalBodies.delete(v.body);
    vehicles.splice(i,1);
  }
  delete tiles[r];
}

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// ì¶©ëŒ (ëª¨ë“  ë™ë¬¼ = ì¦‰ì‚¬)
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
const animalBodies = new Set();

function registerAnimal(v) {
  animalBodies.add(v.body);
}

world.addEventListener('beginContact', (e) => {
  if (player.isDead || gameState !== 'playing') return;
  const {bodyA, bodyB} = e;
  if (bodyA !== playerBody && bodyB !== playerBody) return;
  const other = bodyA===playerBody ? bodyB : bodyA;
  if (animalBodies.has(other)) killPlayer();
});

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// ì´ë™ & ì í”„
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
function tryMove(dx, dz) {
  if (gameState!=='playing' || player.isMoving || player.isDead) return;
  const nx = player.gridX+dx, nz = player.gridZ+dz;
  if (Math.abs(nx) > BOARD_HALF) return;
  if (blocked.has(`${nx},${nz}`)) return;

  player.gridX=nx; player.gridZ=nz;

  // ì´ë™ ë°©í–¥ìœ¼ë¡œ ë¶€ë¦¬ê°€ í–¥í•˜ë„ë¡ íšŒì „ (ë¶€ë¦¬ëŠ” +Z ê¸°ë³¸ê°’)
  if(dz<0)      pGroup.rotation.y = Math.PI;      // ì• â†’ ë¶€ë¦¬ -Z ë°©í–¥
  else if(dx<0) pGroup.rotation.y = -Math.PI/2;   // ì™¼ â†’ ë¶€ë¦¬ -X ë°©í–¥
  else          pGroup.rotation.y = Math.PI/2;     // ì˜¤ë¥¸ â†’ ë¶€ë¦¬ +X ë°©í–¥

  doJump(nx, nz);
  if (dz<0) { score++; document.getElementById('score').textContent=score; }
}

function doJump(tx, tz) {
  player.isMoving = true;
  player.jumpStart = performance.now();
  player.landX = tx * TILE_SIZE;
  player.landZ = tz * TILE_SIZE;
  const vx = (player.landX - playerBody.position.x) / JUMP_TIME;
  const vz = (player.landZ - playerBody.position.z) / JUMP_TIME;
  playerBody.velocity.set(vx, JUMP_VEL, vz);
  playerBody.angularVelocity.set(0,0,0);
}

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// ì‚¬ë§ ì—°ì¶œ
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
function killPlayer() {
  if (player.isDead) return;
  player.isDead = true;
  playerBody.velocity.set(0,0,0);
  playerBody.angularVelocity.set(0,0,0);

  const start = performance.now();
  const raf = () => {
    const t = Math.min((performance.now()-start)/260, 1);
    pGroup.scale.set(1.5+t*.1, 1-t*.95, 1.5+t*.1);
    pGroup.traverse(o => {
      if (o.isMesh && o.name!=='Beak')
        o.material.color.lerp(new THREE.Color(0xe74c3c), t*.9);
    });
    if (t<1) requestAnimationFrame(raf);
    else setTimeout(endGame, 480);
  };
  requestAnimationFrame(raf);
}

function endGame() {
  gameState = 'dead';
  if (score>bestScore) { bestScore=score; localStorage.setItem('animal_crossy_best',bestScore); }
  document.getElementById('finalScore').textContent = score;
  document.getElementById('bestScore').textContent  = `ìµœê³ : ${bestScore}`;
  document.getElementById('gameover').style.display  = 'flex';
  document.getElementById('score').style.display     = 'none';
  document.getElementById('dpad').style.display      = 'none';
  document.getElementById('legend').style.display    = 'none';
}

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// ì‹œì‘ / ë¦¬ì…‹
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
function initMap() {
  for (let r=-2; r<=GEN_AHEAD; r++) genRow(r);
  farRow = GEN_AHEAD;
}

function resetGame() {
  for (const r in tiles) removeRow(+r);
  animalBodies.clear();

  score=0; farRow=GEN_AHEAD;
  document.getElementById('score').textContent='0';

  player.gridX=player.gridZ=0; player.isMoving=false; player.isDead=false;
  playerBody.position.set(0,0.45,0); playerBody.velocity.set(0,0,0); playerBody.angularVelocity.set(0,0,0);
  pGroup.position.set(0,0,0); pGroup.rotation.set(0,Math.PI,0); pGroup.scale.set(1,1,1);
  pGroup.traverse(o => {
    if (o.isMesh) {
      if (o.name==='Beak') o.material.color.set(COL.orange);
      else o.material.color.set(COL.yellow);
    }
  });

  camera.position.copy(CAM_OFFSET); camera.lookAt(new THREE.Vector3(-1, 0, -1));
  gameState = 'playing';
  initMap();
}

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// ì…ë ¥
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
document.addEventListener('keydown', e => {
  if (e.repeat) return; // í‚¤ í™€ë“œ ë°˜ë³µ ë¬´ì‹œ â€” 1í‚¤ 1ì¹¸
  const map = {
    ArrowUp:[0,-1],w:[0,-1],W:[0,-1],
    ArrowLeft:[-1,0],a:[-1,0],A:[-1,0],
    ArrowRight:[1,0],d:[1,0],D:[1,0],
  };
  if (map[e.key]) { e.preventDefault(); tryMove(...map[e.key]); }
});

let ts=null;
document.addEventListener('touchstart',e=>{ts={x:e.touches[0].clientX,y:e.touches[0].clientY};},{passive:true});
document.addEventListener('touchend',e=>{
  if(!ts) return;
  const dx=e.changedTouches[0].clientX-ts.x, dy=e.changedTouches[0].clientY-ts.y;
  const dist=Math.hypot(dx,dy);
  if(dist<20) tryMove(0,-1);
  else if(Math.abs(dx)>Math.abs(dy)) tryMove(dx>0?1:-1,0);
  else if(dy<0) tryMove(0,-1); // ì•ìœ¼ë¡œë§Œ (ë’¤ë¡œ ìŠ¤ì™€ì´í”„ ë¬´ì‹œ)
  ts=null;
},{passive:true});

document.querySelectorAll('#dpad button').forEach(b => {
  b.addEventListener('click', () => tryMove(+b.dataset.dx, +b.dataset.dz));
});

document.getElementById('btnStart').addEventListener('click', () => {
  document.getElementById('menu').style.display   = 'none';
  document.getElementById('score').style.display  = 'block';
  document.getElementById('dpad').style.display   = 'grid';
  document.getElementById('legend').style.display = 'block';
  resetGame();
});
document.getElementById('btnRetry').addEventListener('click', () => {
  document.getElementById('gameover').style.display = 'none';
  document.getElementById('score').style.display    = 'block';
  document.getElementById('dpad').style.display     = 'grid';
  document.getElementById('legend').style.display   = 'block';
  resetGame();
});

window.tryMove = tryMove;

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// ë©”ì¸ ë£¨í”„
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
const camTgt   = new THREE.Vector3();
const FIXED_DT = 1/60;
let   lastTime = 0, physicsAcc = 0;

function animate(now) {
  requestAnimationFrame(animate);
  const delta = Math.min((now-lastTime)/1000, 0.05);
  lastTime = now;

  if (gameState === 'playing') {
    // â”€â”€ ë¬¼ë¦¬ ìŠ¤í… â”€â”€
    physicsAcc += delta;
    while (physicsAcc>=FIXED_DT) { world.step(FIXED_DT); physicsAcc-=FIXED_DT; }

    // â”€â”€ ë™ë¬¼ Kinematic ì´ë™ â”€â”€
    for (const v of vehicles) {
      v.body.velocity.x = v.dir * v.spd;
      let px = v.body.position.x;
      if (px >  v.bound) { px=-v.bound; v.body.position.x=px; v.mesh.position.x=px; }
      if (px < -v.bound) { px= v.bound; v.body.position.x=px; v.mesh.position.x=px; }
      v.mesh.position.x = v.body.position.x;
    }

    // â”€â”€ í”Œë ˆì´ì–´ ë¬¼ë¦¬ â†’ Three ë™ê¸°í™” â”€â”€
    pGroup.position.x = playerBody.position.x;
    pGroup.position.y = Math.max(playerBody.position.y - 0.45, 0);
    pGroup.position.z = playerBody.position.z;

    // â”€â”€ ì°©ì§€ ê°ì§€ â”€â”€
    if (player.isMoving) {
      const elapsed = (now-player.jumpStart)/1000;
      const landed  = elapsed>JUMP_TIME*0.82 && playerBody.velocity.y<=0.1 && playerBody.position.y<0.65;
      if (landed) {
        playerBody.position.set(player.landX, 0.45, player.landZ);
        playerBody.velocity.set(0,0,0);
        player.isMoving = false;
      }
    }

    // â”€â”€ ë§µ ë¬´í•œ ìƒì„± â”€â”€
    const prow = -player.gridZ;          // gridZëŠ” ì•ìœ¼ë¡œ ê°ˆìˆ˜ë¡ ìŒìˆ˜ â†’ prowëŠ” ì–‘ìˆ˜
    const need = prow + GEN_AHEAD;        // ì• ë°©í–¥ìœ¼ë¡œ row ë²ˆí˜¸ ì¦ê°€
    while (farRow < need) { farRow++; genRow(farRow); }
    for (const r in tiles) { if (+r < prow - CULL_BEHIND) removeRow(+r); }

    // â”€â”€ ì¹´ë©”ë¼ ì¶”ì  â”€â”€
    camTgt.copy(pGroup.position).add(CAM_OFFSET);
    camera.position.lerp(camTgt, 0.11);
    camera.lookAt(pGroup.position.x - 1, 0, pGroup.position.z - 1);

    // â”€â”€ í™”ë©´ ë’¤ë¡œ ë°€ë ¤ë‚˜ë©´ ì‚¬ë§ â”€â”€
    if (pGroup.position.z - camera.position.z > 4.5) killPlayer();
  }

  renderer.render(scene, camera);
}

initMap();
requestAnimationFrame(animate);
</script>
</body>
</html>
